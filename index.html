                // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†é–‹
                document.addEventListener('click', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                }, { once: true });
            }
            
            createKeyboard() {
                this.keyMapping.forEach((key, index) => {
                    const keyElement = document.createElement('button');
                    keyElement.className = 'key';
                    keyElement.innerHTML = `
                        <div class="key-number">${index + 1}</div>
                        <div>${key.toUpperCase()}</div>
                        <div class="key-label">Empty</div>
                    `;
                    keyElement.dataset.key = key;
                    keyElement.dataset.index = index;
                    keyElement.addEventListener('mousedown', () => this.playSample(index));
                    keyElement.addEventListener('mouseup', () => this.releaseKey(key));
                    keyElement.addEventListener('mouseleave', () => this.releaseKey(key));
                    this.elements.keyboard.appendChild(keyElement);
                });
            }
            
            async loadAudioFile(event, deck) {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...`);
                    
                    // AudioContextã®çŠ¶æ…‹ã‚’ç¢ºèªãƒ»å¾©å¸°
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    // æ—¢å­˜ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å®Œå…¨ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    await this.cleanupDeck(deck);
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ArrayBufferã¨ã—ã¦èª­ã¿è¾¼ã¿
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    // AudioBufferã‚’ä¿å­˜
                    if (deck === 'A') {
                        this.audioBufferA = audioBuffer;
                        this.currentFilenameA = file.name;
                        this.elements.filenameA.textContent = file.name;
                    } else {
                        this.audioBufferB = audioBuffer;
                        this.currentFilenameB = file.name;
                        this.elements.filenameB.textContent = file.name;
                    }
                    
                    // ç·å†ç”Ÿæ™‚é–“ã‚’æ›´æ–°
                    this.updateTotalTime(deck);
                    
                    // UIè¦ç´ ã‚’æœ‰åŠ¹åŒ–
                    this.enableDeckControls(deck);
                    
                    // BPMæ¤œå‡ºï¼ˆéåŒæœŸã§å®Ÿè¡Œï¼‰
                    this.detectBPM(audioBuffer, deck).catch(error => {
                        console.error('BPM detection failed:', error);
                    });
                    
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã« "${file.name}" ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                    
                } catch (error) {
                    console.error(`Failed to load audio file for deck ${deck}:`, error);
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                    this.resetDeck(deck);
                }
            }
            
            async cleanupDeck(deck) {
                // å†ç”Ÿä¸­ã®BufferSourceã‚’åœæ­¢
                if (deck === 'A' && this.bufferSourceA) {
                    try {
                        this.bufferSourceA.stop();
                    } catch (error) {
                        console.warn('Failed to stop buffer source A:', error);
                    }
                    this.bufferSourceA = null;
                    this.isPlayingA = false;
                } else if (deck === 'B' && this.bufferSourceB) {
                    try {
                        this.bufferSourceB.stop();
                    } catch (error) {
                        console.warn('Failed to stop buffer source B:', error);
                    }
                    this.bufferSourceB = null;
                    this.isPlayingB = false;
                }
                
                // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
                if (deck === 'A') {
                    clearInterval(this.progressIntervalA);
                    this.progressIntervalA = null;
                } else {
                    clearInterval(this.progressIntervalB);
                    this.progressIntervalB = null;
                }
                
                // ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’å¼·åˆ¶çš„ã«ã‚ªãƒ•
                if ((deck === 'A' && this.monitoringA) || (deck === 'B' && this.monitoringB)) {
                    this.forceMonitorOff(deck);
                }
            }
            
            forceMonitorOff(deck) {
                const monitorBtn = this.elements[`monitorBtn${deck}`];
                const monitorGain = deck === 'A' ? this.monitorGainA : this.monitorGainB;
                
                if (monitorGain) {
                    monitorGain.gain.value = 0;
                }
                monitorBtn.classList.remove('active');
                monitorBtn.textContent = 'ãƒ¢ãƒ‹ã‚¿ãƒ¼';
                
                if (deck === 'A') {
                    this.monitoringA = false;
                } else {
                    this.monitoringB = false;
                }
            }
            
            enableDeckControls(deck) {
                try {
                    this.elements[`playBtn${deck}`].disabled = false;
                    this.elements[`pauseBtn${deck}`].disabled = false;
                    this.elements[`stopBtn${deck}`].disabled = false;
                    this.elements[`monitorBtn${deck}`].disabled = false;
                    this.elements.recordBtn.disabled = false;
                } catch (error) {
                    console.error(`Failed to enable controls for deck ${deck}:`, error);
                }
            }
            
            resetDeck(deck) {
                try {
                    // å†ç”Ÿåœæ­¢
                    this.stopAudio(deck);
                    
                    // UIè¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.elements[`playBtn${deck}`].disabled = true;
                    this.elements[`pauseBtn${deck}`].disabled = true;
                    this.elements[`stopBtn${deck}`].disabled = true;
                    this.elements[`monitorBtn${deck}`].disabled = true;
                    
                    // ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’å¼·åˆ¶çš„ã«ã‚ªãƒ•
                    this.forceMonitorOff(deck);
                    
                    // ãƒ”ãƒƒãƒã¨ãƒœãƒªãƒ¥ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.elements[`pitchSlider${deck}`].value = 0;
                    this.elements[`pitchValue${deck}`].textContent = '0%';
                    this.elements[`volumeSlider${deck}`].value = 75;
                    this.elements[`volumeValue${deck}`].textContent = '75%';
                    
                    // è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.elements[`filename${deck}`].textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãªã—';
                    this.elements[`bpmValue${deck}`].textContent = '--';
                    this.elements[`currentBpm${deck}`].textContent = '--';
                    this.elements[`progressFill${deck}`].style.width = '0%';
                    this.elements[`currentTime${deck}`].textContent = '0:00';
                    this.elements[`totalTime${deck}`].textContent = '0:00';
                    
                    // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                    if (deck === 'A') {
                        this.audioBufferA = null;
                        this.currentFilenameA = null;
                        this.originalBpmA = null;
                        this.playbackRateA = 1;
                        this.pauseTimeA = 0;
                    } else {
                        this.audioBufferB = null;
                        this.currentFilenameB = null;
                        this.originalBpmB = null;
                        this.playbackRateB = 1;
                        this.pauseTimeB = 0;
                    }
                    
                } catch (error) {
                    console.error(`Failed to reset deck ${deck}:`, error);
                }
            }
            
            async detectBPM(audioBuffer, deck) {
                try {
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®BPMã‚’æ¤œå‡ºä¸­...`);
                    
                    const bpm = await Promise.race([
                        this.calculateBPMImproved(audioBuffer),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('BPM detection timeout')), 15000)
                        )
                    ]);
                    
                    if (deck === 'A') {
                        this.originalBpmA = bpm;
                    } else {
                        this.originalBpmB = bpm;
                    }
                    
                    this.elements[`bpmValue${deck}`].textContent = Math.round(bpm);
                    this.updateCurrentBPM(deck);
                    
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®BPMæ¤œå‡ºå®Œäº†: ${Math.round(bpm)}`);
                    
                } catch (error) {
                    console.error('BPM detection error:', error);
                    this.elements[`bpmValue${deck}`].textContent = '120';
                    this.elements[`currentBpm${deck}`].textContent = '120';
                    
                    if (deck === 'A') {
                        this.originalBpmA = 120;
                    } else {
                        this.originalBpmB = 120;
                    }
                    
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®BPMæ¤œå‡ºã«å¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤(120)ã‚’ä½¿ç”¨`);
                }
            }
            
            calculateBPMImproved(audioBuffer) {
                return new Promise((resolve) => {
                    const sampleRate = audioBuffer.sampleRate;
                    const samples = audioBuffer.getChannelData(0);
                    
                    // åˆ†æã™ã‚‹é•·ã•ã‚’åˆ¶é™ï¼ˆæœ€åˆã®60ç§’ã¾ãŸã¯å…¨ä½“ã®1/3ï¼‰
                    const maxSamples = Math.min(samples.length, sampleRate * 60, samples.length / 3);
                    const analysisBuffer = samples.slice(0, maxSamples);
                    
                    // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’é©ç”¨ã—ã¦ãƒã‚¤ã‚ºã‚’é™¤å»
                    const filteredSamples = this.applyLowPassFilter(analysisBuffer, sampleRate);
                    
                    // ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ™ãƒ¼ã‚¹ã®ã‚ªãƒ³ã‚»ãƒƒãƒˆæ¤œå‡º
                    const onsets = this.detectOnsets(filteredSamples, sampleRate);
                    
                    if (onsets.length < 4) {
                        resolve(120);
                        return;
                    }
                    
                    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«åˆ†æ
                    const intervals = [];
                    for (let i = 1; i < onsets.length; i++) {
                        const interval = onsets[i] - onsets[i - 1];
                        if (interval > 0.2 && interval < 2.0) {
                            intervals.push(interval);
                        }
                    }
                    
                    if (intervals.length === 0) {
                        resolve(120);
                        return;
                    }
                    
                    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ åˆ†æ
                    const bpmCandidates = intervals.map(interval => 60 / interval);
                    const histogram = this.createBPMHistogram(bpmCandidates);
                    
                    // æœ€ã‚‚é »ç¹ãªBPMã‚’é¸æŠ
                    let maxCount = 0;
                    let bestBPM = 120;
                    
                    for (const [bpm, count] of histogram.entries()) {
                        if (count > maxCount && bpm >= 60 && bpm <= 200) {
                            maxCount = count;
                            bestBPM = bpm;
                        }
                    }
                    
                    resolve(bestBPM);
                });
            }
            
            applyLowPassFilter(samples, sampleRate) {
                const cutoff = 200;
                const rc = 1.0 / (cutoff * 2 * Math.PI);
                const dt = 1.0 / sampleRate;
                const alpha = dt / (rc + dt);
                
                const filtered = new Float32Array(samples.length);
                filtered[0] = samples[0];
                
                for (let i = 1; i < samples.length; i++) {
                    filtered[i] = alpha * samples[i] + (1 - alpha) * filtered[i - 1];
                }
                
                return filtered;
            }
            
            detectOnsets(samples, sampleRate) {
                const hopSize = Math.floor(sampleRate * 0.01);
                const windowSize = hopSize * 4;
                const onsets = [];
                
                let previousEnergy = 0;
                const threshold = 0.1;
                
                for (let i = 0; i < samples.length - windowSize; i += hopSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        const sample = samples[i + j];
                        energy += sample * sample;
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (energy > previousEnergy + threshold && energy > 0.05) {
                        const time = i / sampleRate;
                        if (onsets.length === 0 || time - onsets[onsets.length - 1] > 0.1) {
                            onsets.push(time);
                        }
                    }
                    
                    previousEnergy = energy * 0.9;
                }
                
                return onsets;
            }
            
            createBPMHistogram(bpmCandidates) {
                const histogram = new Map();
                const tolerance = 3;
                
                for (const bpm of bpmCandidates) {
                    let found = false;
                    
                    for (const [existingBPM, count] of histogram.entries()) {
                        if (Math.abs(bpm - existingBPM) <= tolerance) {
                            histogram.set(existingBPM, count + 1);
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        histogram.set(Math.round(bpm), 1);
                    }
                }
                
                return histogram;
            }
            
            updateCurrentBPM(deck) {
                const originalBpm = deck === 'A' ? this.originalBpmA : this.originalBpmB;
                const playbackRate = deck === 'A' ? this.playbackRateA : this.playbackRateB;
                if (originalBpm) {
                    const currentBpm = originalBpm * playbackRate;
                    this.elements[`currentBpm${deck}`].textContent = Math.round(currentBpm);
                }
            }
            
            playAudio(deck) {
                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const audioBuffer = deck === 'A' ? this.audioBufferA : this.audioBufferB;
                    if (!audioBuffer) {
                        throw new Error(`Audio buffer for deck ${deck} not loaded`);
                    }
                    
                    // æ—¢å­˜ã®BufferSourceã‚’åœæ­¢
                    if (deck === 'A' && this.bufferSourceA) {
                        this.bufferSourceA.stop();
                        this.bufferSourceA = null;
                    } else if (deck === 'B' && this.bufferSourceB) {
                        this.bufferSourceB.stop();
                        this.bufferSourceB = null;
                    }
                    
                    // æ–°ã—ã„BufferSourceã‚’ä½œæˆ
                    const bufferSource = this.audioContext.createBufferSource();
                    bufferSource.buffer = audioBuffer;
                    
                    // ãƒ”ãƒƒãƒèª¿æ•´ã‚’é©ç”¨
                    const playbackRate = deck === 'A' ? this.playbackRateA : this.playbackRateB;
                    bufferSource.playbackRate.value = playbackRate;
                    
                    // æ¥ç¶š
                    const gainNode = deck === 'A' ? this.deckAGainNode : this.deckBGainNode;
                    bufferSource.connect(gainNode);
                    
                    // å†ç”Ÿé–‹å§‹ä½ç½®ã‚’è¨ˆç®—
                    const pauseTime = deck === 'A' ? this.pauseTimeA : this.pauseTimeB;
                    const startOffset = Math.min(pauseTime, audioBuffer.duration - 0.1);
                    
                    // å†ç”Ÿé–‹å§‹
                    bufferSource.start(0, startOffset);
                    
                    // çŠ¶æ…‹æ›´æ–°
                    if (deck === 'A') {
                        this.bufferSourceA = bufferSource;
                        this.isPlayingA = true;
                        this.startTimeA = this.audioContext.currentTime - startOffset / playbackRate;
                        this.pauseTimeA = 0;
                        
                        bufferSource.onended = () => {
                            this.isPlayingA = false;
                            this.bufferSourceA = null;
                            this.updateStatus('ãƒ‡ãƒƒã‚­Aã®å†ç”ŸãŒçµ‚äº†ã—ã¾ã—ãŸ');
                            clearInterval(this.progressIntervalA);
                            this.updateProgress('A');
                        };
                        
                        // å†ç”Ÿé€²æ—æ›´æ–°
                        this.progressIntervalA = setInterval(() => this.updateProgress('A'), 100);
                    } else {
                        this.bufferSourceB = bufferSource;
                        this.isPlayingB = true;
                        this.startTimeB = this.audioContext.currentTime - startOffset / playbackRate;
                        this.pauseTimeB = 0;
                        
                        bufferSource.onended = () => {
                            this.isPlayingB = false;
                            this.bufferSourceB = null;
                            this.updateStatus('ãƒ‡ãƒƒã‚­Bã®å†ç”ŸãŒçµ‚äº†ã—ã¾ã—ãŸ');
                            clearInterval(this.progressIntervalB);
                            this.updateProgress('B');
                        };
                        
                        // å†ç”Ÿé€²æ—æ›´æ–°
                        this.progressIntervalB = setInterval(() => this.updateProgress('B'), 100);
                    }
                    
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã‚’å†ç”Ÿä¸­...`);
                    
                } catch (error) {
                    console.error(`Audio play error for deck ${deck}:`, error);
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®å†ç”Ÿã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ`);
                }
            }
            
            pauseAudio(deck) {
                try {
                    const bufferSource = deck === 'A' ? this.bufferSourceA : this.bufferSourceB;
                    const isPlaying = deck === 'A' ? this.isPlayingA : this.isPlayingB;
                    const startTime = deck === 'A' ? this.startTimeA : this.startTimeB;
                    
                    if (bufferSource && isPlaying) {
                        bufferSource.stop();
                        
                        // ç¾åœ¨ã®å†ç”Ÿä½ç½®ã‚’è¨ˆç®—
                        const currentTime = this.audioContext.currentTime;
                        const elapsedTime = currentTime - startTime;
                        const playbackRate = deck === 'A' ? this.playbackRateA : this.playbackRateB;
                        const currentPosition = elapsedTime * playbackRate;
                        
                        if (deck === 'A') {
                            this.pauseTimeA = currentPosition;
                            this.isPlayingA = false;
                            this.bufferSourceA = null;
                            clearInterval(this.progressIntervalA);
                        } else {
                            this.pauseTimeB = currentPosition;
                            this.isPlayingB = false;
                            this.bufferSourceB = null;
                            clearInterval(this.progressIntervalB);
                        }
                        
                        this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã‚’ä¸€æ™‚åœæ­¢ä¸­`);
                    }
                } catch (error) {
                    console.error(`Pause error for deck ${deck}:`, error);
                }
            }
            
            stopAudio(deck) {
                try {
                    const bufferSource = deck === 'A' ? this.bufferSourceA : this.bufferSourceB;
                    
                    if (bufferSource) {
                        bufferSource.stop();
                    }
                    
                    if (deck === 'A') {
                        this.isPlayingA = false;
                        this.bufferSourceA = null;
                        this.pauseTimeA = 0;
                        clearInterval(this.progressIntervalA);
                    } else {
                        this.isPlayingB = false;
                        this.bufferSourceB = null;
                        this.pauseTimeB = 0;
                        clearInterval(this.progressIntervalB);
                    }
                    
                    this.updateProgress(deck);
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã‚’åœæ­¢ã—ã¾ã—ãŸ`);
                } catch (error) {
                    console.error(`Stop error for deck ${deck}:`, error);
                }
            }
            
            updatePitch(event, deck) {
                const value = parseInt(event.target.value);
                const pitchMultiplier = 1 + (value / 100);
                
                if (deck === 'A') {
                    this.playbackRateA = pitchMultiplier;
                } else {
                    this.playbackRateB = pitchMultiplier;
                }
                
                // å†ç”Ÿä¸­ã®å ´åˆã¯å†é–‹
                const isPlaying = deck === 'A' ? this.isPlayingA : this.isPlayingB;
                if (isPlaying) {
                    this.pauseAudio(deck);
                    setTimeout(() => this.playAudio(deck), 50);
                }
                
                this.elements[`pitchValue${deck}`].textContent = `${value > 0 ? '+' : ''}${value}%`;
                this.updateCurrentBPM(deck);
            }
            
            resetPitch(deck) {
                this.elements[`pitchSlider${deck}`].value = 0;
                
                if (deck === 'A') {
                    this.playbackRateA = 1;
                } else {
                    this.playbackRateB = 1;
                }
                
                // å†ç”Ÿä¸­ã®å ´åˆã¯å†é–‹
                const isPlaying = deck === 'A' ? this.isPlayingA : this.isPlayingB;
                if (isPlaying) {
                    this.pauseAudio(deck);
                    setTimeout(() => this.playAudio(deck), 50);
                }
                
                this.elements[`pitchValue${deck}`].textContent = '0%';
                this.updateCurrentBPM(deck);
            }
            
            updatePreservePitch(event, deck) {
                // BufferSourceNodeã§ã¯éŸ³ç¨‹ä¿æŒæ©Ÿèƒ½ã¯ç›´æ¥ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãŸã‚ã€
                // ã“ã®æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¾ã™
                console.log(`Preserve pitch setting for deck ${deck}: ${event.target.checked}`);
            }
            
            updateVolume(event, deck) {
                const volume = event.target.value / 100;
                const gainNode = deck === 'A' ? this.deckAGainNode : this.deckBGainNode;
                if (gainNode) {
                    gainNode.gain.value = volume;
                }
                this.elements[`volumeValue${deck}`].textContent = event.target.value + '%';
            }
            
            updateCrossfader(event) {
                const value = parseInt(event.target.value);
                
                // ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ€ãƒ¼ã®å€¤ã«åŸºã¥ã„ã¦ã‚²ã‚¤ãƒ³ã‚’èª¿æ•´
                const gainA = Math.cos((value / 100) * (Math.PI / 2));
                const gainB = Math.sin((value / 100) * (Math.PI / 2));
                
                if (this.crossfaderGainA) {
                    this.crossfaderGainA.gain.value = gainA;
                }
                if (this.crossfaderGainB) {
                    this.crossfaderGainB.gain.value = gainB;
                }
            }
            
            seekAudio(event, deck) {
                try {
                    const audioBuffer = deck === 'A' ? this.audioBufferA : this.audioBufferB;
                    if (!audioBuffer) return;
                    
                    const rect = this.elements[`progressBar${deck}`].getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const percentage = clickX / rect.width;
                    const newPosition = percentage * audioBuffer.duration;
                    
                    // æ–°ã—ã„ä½ç½®ã‚’è¨­å®š
                    if (deck === 'A') {
                        this.pauseTimeA = newPosition;
                    } else {
                        this.pauseTimeB = newPosition;
                    }
                    
                    // å†ç”Ÿä¸­ã®å ´åˆã¯å†é–‹
                    const isPlaying = deck === 'A' ? this.isPlayingA : this.isPlayingB;
                    if (isPlaying) {
                        this.pauseAudio(deck);
                        setTimeout(() => this.playAudio(deck), 50);
                    } else {
                        this.updateProgress(deck);
                    }
                } catch (error) {
                    console.error(`Seek error for deck ${deck}:`, error);
                }
            }
            
            updateTotalTime(deck) {
                const audioBuffer = deck === 'A' ? this.audioBufferA : this.audioBufferB;
                if (audioBuffer) {
                    const duration = audioBuffer.duration;
                    this.elements[`totalTime${deck}`].textContent = this.formatTime(duration);
                }
            }
            
            updateProgress(deck) {
                try {
                    const audioBuffer = deck === 'A' ? this.audioBufferA : this.audioBufferB;
                    const isPlaying = deck === 'A' ? this.isPlayingA : this.isPlayingB;
                    const startTime = deck === 'A' ? this.startTimeA : this.startTimeB;
                    const pauseTime = deck === 'A' ? this.pauseTimeA : this.pauseTimeB;
                    const playbackRate = deck === 'A' ? this.playbackRateA : this.playbackRateB;
                    
                    if (!audioBuffer) return;
                    
                    let currentTime;
                    if (isPlaying) {
                        const elapsedTime = this.audioContext.currentTime - startTime;
                        currentTime = pauseTime + (elapsedTime * playbackRate);
                    } else {
                        currentTime = pauseTime;
                    }
                    
                    // ç¯„å›²ãƒã‚§ãƒƒã‚¯
                    currentTime = Math.max(0, Math.min(currentTime, audioBuffer.duration));
                    
                    const percentage = (currentTime / audioBuffer.duration) * 100;
                    this.elements[`progressFill${deck}`].style.width = percentage + '%';
                    this.elements[`currentTime${deck}`].textContent = this.formatTime(currentTime);
                } catch (error) {
                    console.error(`Progress update error for deck ${deck}:`, error);
                }
            }
            
            toggleMonitor(deck) {
                const isMonitoring = deck === 'A' ? this.monitoringA : this.monitoringB;
                const monitorBtn = this.elements[`monitorBtn${deck}`];
                const monitorGain = deck === 'A' ? this.monitorGainA : this.monitorGainB;
                
                if (isMonitoring) {
                    if (monitorGain) {
                        monitorGain.gain.value = 0;
                    }
                    monitorBtn.classList.remove('active');
                    monitorBtn.textContent = 'ãƒ¢ãƒ‹ã‚¿ãƒ¼';
                    if (deck === 'A') {
                        this.monitoringA = false;
                    } else {
                        this.monitoringB = false;
                    }
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’ã‚ªãƒ•ã«ã—ã¾ã—ãŸ`);
                } else {
                    if (monitorGain) {
                        monitorGain.gain.value = 0.5;
                    }
                    monitorBtn.classList.add('active');
                    monitorBtn.textContent = 'ãƒ¢ãƒ‹ã‚¿ãƒ¼ä¸­';
                    if (deck === 'A') {
                        this.monitoringA = true;
                    } else {
                        this.monitoringB = true;
                    }
                    this.updateStatus(`ãƒ‡ãƒƒã‚­${deck}ã®ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’ã‚ªãƒ³ã«ã—ã¾ã—ãŸ`);
                }
            }
            
            stopAllSounds() {
                this.stopAudio('A');
                this.stopAudio('B');
                
                this.playingSamples.forEach(source => {
                    try {
                        source.stop();
                    } catch (error) {
                        // ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ï¼ˆæ—¢ã«åœæ­¢æ¸ˆã¿ã®å ´åˆï¼‰
                    }
                });
                this.playingSamples.clear();
                
                document.querySelectorAll('.key').forEach(key => {
                    key.classList.remove('active', 'playing');
                });
                
                this.updateStatus('å…¨ã¦ã®éŸ³ã‚’åœæ­¢ã—ã¾ã—ãŸ');
            }
            
            // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ©Ÿèƒ½
            async loadPresetSamples() {
                this.updateStatus('ãƒ—ãƒªã‚»ãƒƒãƒˆã‚µãƒ³ãƒ—ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...');
                
                let loadedCount = 0;
                for (let i = 0; i < this.presetSamples.length; i++) {
                    try {
                        const response = await fetch(this.presetSamples[i]);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        
                        const fileName = this.presetSamples[i].split('/').pop().split('.')[0];
                        this.samples[i] = {
                            buffer: audioBuffer,
                            name: fileName,
                            isPreset: true
                        };
                        
                        const keyElement = document.querySelector(`[data-index="${i}"]`);
                        if (keyElement) {
                            const label = keyElement.querySelector('.key-label');
                            label.textContent = fileName.substring(0, 6);
                        }
                        
                        loadedCount++;
                        
                    } catch (error) {
                        console.error(`Sample ${this.presetSamples[i]} loading error:`, error);
                        const keyElement = document.querySelector(`[data-index="${i}"]`);
                        if (keyElement) {
                            const label = keyElement.querySelector('.key-label');
                            label.textContent = 'Error';
                        }
                    }
                }
                
                this.updateStatus(`${loadedCount}å€‹ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚µãƒ³ãƒ—ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
            }
            
            async loadSampleFiles(event) {
                const files = Array.from(event.target.files);
                const maxAdditionalSamples = 23;
                const startIndex = this.presetSamples.length;
                
                if (files.length > maxAdditionalSamples) {
                    alert(`æœ€å¤§${maxAdditionalSamples}å€‹ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã¾ã§é¸æŠã§ãã¾ã™ã€‚`);
                    return;
                }
                
                // æ—¢å­˜ã®è¿½åŠ ã‚µãƒ³ãƒ—ãƒ«ã‚’ã‚¯ãƒªã‚¢
                for (let i = startIndex; i < 50; i++) {
                    if (this.samples[i] && !this.samples[i].isPreset) {
                        this.samples[i] = null;
                        const keyElement = document.querySelector(`[data-index="${i}"]`);
                        if (keyElement) {
                            const label = keyElement.querySelector('.key-label');
                            label.textContent = 'Empty';
                        }
                    }
                }
                
                let loadedCount = 0;
                
                for (let i = 0; i < files.length && (startIndex + i) < 50; i++) {
                    const file = files[i];
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        
                        const sampleIndex = startIndex + i;
                        this.samples[sampleIndex] = {
                            buffer: audioBuffer,
                            name: file.name.split('.')[0],
                            isPreset: false
                        };
                        
                        const keyElement = document.querySelector(`[data-index="${sampleIndex}"]`);
                        if (keyElement) {
                            const label = keyElement.querySelector('.key-label');
                            label.textContent = this.samples[sampleIndex].name.substring(0, 6);
                        }
                        
                        loadedCount++;
                    } catch (error) {
                        console.error(`Sample ${file.name} loading error:`, error);
                    }
                }
                
                this.updateStatus(`${loadedCount}å€‹ã®è¿½åŠ ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
            }
            
            playSample(index) {
                if (this.samples[index] && this.audioContext) {
                    try {
                        const source = this.audioContext.createBufferSource();
                        source.buffer = this.samples[index].buffer;
                        source.connect(this.sampleGainNode);
                        
                        source.onended = () => {
                            this.playingSamples.delete(source);
                            this.releaseKey(this.keyMapping[index]);
                        };
                        
                        source.start();
                        this.playingSamples.add(source);
                        this.activateKey(this.keyMapping[index]);
                        
                    } catch (error) {
                        console.error('Sample play error:', error);
                    }
                }
            }
            
            activateKey(key) {
                const keyElement = document.querySelector(`[data-key="${key}"]`);
                if (keyElement) {
                    keyElement.classList.add('active', 'playing');
                }
            }
            
            releaseKey(key) {
                const keyElement = document.querySelector(`[data-key="${key}"]`);
                if (keyElement) {
                    keyElement.classList.remove('active');
                    setTimeout(() => {
                        keyElement.classList.remove('playing');
                    }, 100);
                }
            }
            
            handleKeyPress(event) {
                if (event.repeat) return;
                
                const key = event.key.toLowerCase();
                const index = this.keyMapping.indexOf(key);
                
                if (index !== -1) {
                    event.preventDefault();
                    this.playSample(index);
                }
            }
            
            handleKeyRelease(event) {
                const key = event.key.toLowerCase();
                if (this.keyMapping.includes(key)) {
                    this.releaseKey(key);
                }
            }
            
            updateSampleVolume(event) {
                const volume = event.target.value / 100;
                if (this.sampleGainNode) {
                    this.sampleGainNode.gain.value = volume;
                }
                this.elements.sampleVolumeValue.textContent = event.target.value + '%';
            }
            
            // éŒ²éŸ³æ©Ÿèƒ½
            async toggleRecording() {
                if (!this.isRecording) {
                    await this.startRecording();
                } else {
                    this.stopRecording();
                }
            }
            
            async startRecording() {
                try {
                    if (!this.audioContext || !this.destination) {
                        throw new Error('Audio context not initialized');
                    }
                    
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm';
                    
                    this.mediaRecorder = new MediaRecorder(this.destination.stream, {
                        mimeType: mimeType,
                        audioBitsPerSecond: 128000
                    });
                    
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.saveRecording();
                    };
                    
                    this.mediaRecorder.start(100);
                    this.isRecording = true;
                    this.elements.recordBtn.textContent = 'éŒ²éŸ³åœæ­¢';
                    this.elements.recordBtn.classList.add('recording');
                    this.updateStatus('ğŸ”´ éŒ²éŸ³ä¸­... å…¨ã¦ã®éŸ³ãŒéŒ²éŸ³ã•ã‚Œã¦ã„ã¾ã™');
                    
                } catch (error) {
                    console.error('éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('éŒ²éŸ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒå¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                }
            }
            
            stopRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                
                this.isRecording = false;
                this.elements.recordBtn.textContent = 'éŒ²éŸ³é–‹å§‹';
                this.elements.recordBtn.classList.remove('recording');
                this.updateStatus('éŒ²éŸ³ã‚’åœæ­¢ã—ã¾ã—ãŸ');
            }
            
            async saveRecording() {
                if (this.recordedChunks.length > 0) {
                    const blob = new Blob(this.recordedChunks, { 
                        type: this.recordedChunks[0].type || 'audio/webm' 
                    });
                    
                    await this.convertToMP3(blob);
                }
            }
            
            async convertToMP3(webmBlob) {
                try {
                    this.updateStatus('MP3å½¢å¼ã«å¤‰æ›ä¸­...');
                    
                    const arrayBuffer = await webmBlob.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    const mp3encoder = new lamejs.Mp3Encoder(1, audioBuffer.sampleRate, 128);
                    
                    const samples = audioBuffer.getChannelData(0);
                    const sampleBlockSize = 1152;
                    const mp3Data = [];
                    
                    for (let i = 0; i < samples.length; i += sampleBlockSize) {
                        const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                        const mp3buf = mp3encoder.encodeBuffer(this.convertFloat32ToInt16(sampleChunk));
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                    }
                    
                    const mp3buf = mp3encoder.flush();
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                    }
                    
                    const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
                    this.downloadFile(mp3Blob, 'mp3');
                    
                } catch (error) {
                    console.error('MP3å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('MP3å¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸã€‚WebMå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚');
                    this.downloadFile(webmBlob, 'webm');
                }
            }
            
            convertFloat32ToInt16(buffer) {
                const l = buffer.length;
                const buf = new Int16Array(l);
                for (let i = 0; i < l; i++) {
                    buf[i] = Math.min(1, buffer[i]) * 0x7FFF;
                }
                return buf;
            }
            
            getJSTTimestamp() {
                const now = new Date();
                const jstTime = new Date(now.getTime() + (9 * 60 * 60 * 1000));
                
                const year = jstTime.getUTCFullYear();
                const month = String(jstTime.getUTCMonth() + 1).padStart(2, '0');
                const day = String(jstTime.getUTCDate()).padStart(2, '0');
                const hours = String(jstTime.getUTCHours()).padStart(2, '0');
                const minutes = String(jstTime.getUTCMinutes()).padStart(2, '0');
                const seconds = String(jstTime.getUTCSeconds()).padStart(2, '0');
                
                return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
            }
            
            downloadFile(blob, format) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = this.getJSTTimestamp();
                a.download = `dj_mix_${timestamp}.${format}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateStatus(`éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ${format.toUpperCase()}å½¢å¼ï¼‰ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼`);
            }
            
            formatTime(seconds) {
                if (isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            updateStatus(message) {
                this.elements.status.innerHTML = this.isRecording ? 
                    `<span class="recording-indicator"></span>${message}` : message;
            }
            
            cleanup() {
                // ObjectURLsã‚’ã™ã¹ã¦è§£æ”¾
                this.objectUrls.forEach(url => {
                    URL.revokeObjectURL(url);
                });
                this.objectUrls.clear();
                
                // BufferSourcesã‚’åœæ­¢
                if (this.bufferSourceA) {
                    this.bufferSourceA.stop();
                    this.bufferSourceA = null;
                }
                if (this.bufferSourceB) {
                    this.bufferSourceB.stop();
                    this.bufferSourceB = null;
                }
                
                // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
                clearInterval(this.progressIntervalA);
                clearInterval(this.progressIntervalB);
                
                // AudioContextã‚’é–‰ã˜ã‚‹
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close();
                }
            }
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new DJMixer();
        });
    </script>
</body>
</html>
