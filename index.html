async convertToMP3(webmBlob) {
    try {
        this.updateStatus('MP3形式に変換中...');
        
        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        
        const mp3encoder = new lamejs.Mp3Encoder(1, audioBuffer.sampleRate, 128);
        
        const samples = audioBuffer.getChannelData(0);
        const sampleBlockSize = 1152;
        const mp3Data = [];
        
        for (let i = 0; i < samples.length; i += sampleBlockSize) {
            const sampleChunk = samples.subarray(i, i + sampleBlockSize);
            const mp3buf = mp3encoder.encodeBuffer(this.convertFloat32ToInt16(sampleChunk));
            if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
            }
        }
        
        const mp3buf = mp3encoder.flush();
        if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
        }
        
        const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
        this.downloadFile(mp3Blob, 'mp3');
        
    } catch (error) {
        console.error('MP3変換エラー:', error);
        this.updateStatus('MP3変換に失敗しました。WebM形式でダウンロードします。');
        this.downloadFile(webmBlob, 'webm');
    }
}

convertFloat32ToInt16(buffer) {
    const l = buffer.length;
    const buf = new Int16Array(l);
    
    for (let i = 0; i < l; i++) {
        buf[i] = Math.min(1, buffer[i]) * 0x7FFF;
    }
    return buf;
}

getJSTTimestamp() {
    const now = new Date();
    const jstTime = new Date(now.getTime() + (9 * 60 * 60 * 1000));
    
    const year = jstTime.getUTCFullYear();
    const month = String(jstTime.getUTCMonth() + 1).padStart(2, '0');
    const day = String(jstTime.getUTCDate()).padStart(2, '0');
    const hours = String(jstTime.getUTCHours()).padStart(2, '0');
    const minutes = String(jstTime.getUTCMinutes()).padStart(2, '0');
    const seconds = String(jstTime.getUTCSeconds()).padStart(2, '0');
    
    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
}

downloadFile(blob, format) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = this.getJSTTimestamp();
    a.download = `dj_sampling_mix_${timestamp}.${format}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.updateStatus(`録音ファイル（${format.toUpperCase()}形式）をダウンロードしました！`);
}

formatTime(seconds) {
    if (isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

updateStatus(message) {
    this.elements.status.innerHTML = this.isRecording ? 
        `<span class="recording-indicator"></span>${message}` : message;
}

cleanup() {
    // ObjectURLsをすべて解放
    this.objectUrls.forEach(url => {
        URL.revokeObjectURL(url);
    });
    this.objectUrls.clear();
    
    // BufferSourcesを停止
    if (this.bufferSourceA) {
        this.bufferSourceA.stop();
        this.bufferSourceA = null;
    }
    if (this.bufferSourceB) {
        this.bufferSourceB.stop();
        this.bufferSourceB = null;
    }
    
    // インターバルをクリア
    clearInterval(this.progressIntervalA);
    clearInterval(this.progressIntervalB);
    
    // AudioContextを閉じる
    if (this.audioContext && this.audioContext.state !== 'closed') {
        this.audioContext.close();
    }
}
}

// アプリケーション初期化
document.addEventListener('DOMContentLoaded', () => {
    new DJMixer();
});
</script>
</body>
</html>
